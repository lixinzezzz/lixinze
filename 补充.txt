表级锁：不走索引时候加在表上
行级锁：走索引时候加在索引键上
加锁的基本单位是next-key-lock
locking reads，UPDATE和DELETE时，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。


处理器提供：

总线锁定
当一个处理器要操作共享变量时，在 BUS 总线上发出一个 Lock 信号，其他处理就无法操作这个共享变量了。

缓存锁定
后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现的。

底层硬件通过将 CAS 里的多个操作在硬件层面语义实现上，通过一条处理器指令保证了原子性操作。

每次select, 都会生成当前事务的readview
提交读: 同一事务, 每次select都会去获取新的readview
可重复读: 同一个事务, 每次select的readview是不变的。
都基于MVCC

简单工厂: 一个工厂生成不同的类的对象
工厂方法: 每个具体类有自己的工厂和生成对象的方法
抽象工厂: 每个工厂生成相关的类的对象

共享内存: 

命名管道和匿名管道:

线程工厂: ThreadFactory 实现newThread()方法, 创建线程池所用的线程

HashMap循环链表: 两个线程扩容的时候, 扩容的时候新链表会倒序, 一个线程扩好后令一个又扩就回产生环

String对象:
"a": 1
new String("a"): 2
"a" + "b" -> "ab": 1
s + "a" -> StringBuilder: 3

数据库约束:
NOT NULL
UNIQUE
PRIMARY KEY
FOREIGN KEY
CHECK

ARP

http1.1流水线: 可以同时发送多个消息, 但必须按序响应, 响应完上一个才能到下一个
http2.0多路复用: 不需要按序响应, 顺序可以不同; 存在TCP队头阻塞, 如果前面的数据丢失, 后面的数据就算到达了也不会通知应用层来处理
QUIC: 基于UDP, 即便某个消息丢失, 也不会阻塞其他消息响应

