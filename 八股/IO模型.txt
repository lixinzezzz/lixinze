IO模型

1. 五种IO模型
一个IO操作分为等待数据准备好和从内核向进程复制数据两个阶段
阻塞/非阻塞: 指进程等待数据准备好的阶段是否阻塞
同步/异步: 指进程将数据从内核缓冲区复制到应用进程缓冲区的阶段是否阻塞
a. 阻塞式 I/O
应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
b. 非阻塞式 I/O
应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O 是否完成，即轮询。
由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。
c. I/O 复用
使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
它可以让单个进程具有处理多个 I/O 事件的能力。
d. 信号驱动 I/O
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。
相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。
e. 异步 I/O
应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

2. select vs poll vs epoll
a. select:
描述符存放在数组，大小固定；每次调用需要将全部描述符从进程缓冲区复制到内核缓冲区；通过轮询查找IO完成的进程
b. poll:
描述符存放在链表，大小不固定；每次调用需要将全部描述符从进程缓冲区复制到内核缓冲区；通过轮询查找IO完成的进程
c. epoll:
只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，已注册的描述符在内核中存在一个红黑树上；进程不需要通过轮询来获得事件完成的描述符，内核中维护了就绪的文件描述符的list；只用于linux
多路复用需要给每个事件维护一个等待线程的队列。select和poll每次调用需要把线程轮流添加到队列上；epoll把事件的注册和等待拆开，只需要在事件注册时候添加到队列，不需要每次都添加

3. epoll ET vs LT
epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。
a. LT 模式:
当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
b. ET 模式:
和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。
很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
