1. CAP

a. 一致性(Consistency): 所有节点访问同一份最新的数据副本。
b. 可用性(Availability): 每次请求都能获取到非错的响应，但不保证获取的数据为最新数据
c. 分区容错性(Partition tolerance): 允许一些节点发生错误

CAP不能同时满足。关系型数据库满足CA。

2. BASE

BASE是Basically Available(基本可用)、Soft state(软状态)和Eventually consistent(最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为柔性事务。

a. 基本可用(BA): 分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网址交易付款出现问题来，商品依然可以正常浏览。
b. 软状态(S): 由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单中的“支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
c. 最终一致性(E): 最终一致是指的经过一段时间后，所有节点数据都将会达到一致。如订单的“支付中”状态，最终会变为“支付成功”或者“支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。

3. 分布式锁

a. 数据库的唯一索引
获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。
问题：
    锁没有失效时间，解锁失败的话其它进程无法再获得该锁。
    只能是非阻塞锁，插入失败直接就报错了，无法重试。
    不可重入，已经获得锁的进程也必须重新获取锁。

b. Redis的SETNX指令
使用SETNX指令插入一个键值对，如果 Key 已经存在，那么会返回False，否则插入成功并返回True。
SETNX指令和数据库的唯一索引类似，保证了只存在一个Key的键值对，那么可以用一个Key的键值对是否存在来判断是否存于锁定状态。
EXPIRE指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。
可以同时把SETNX和EXPIRE合成一条指令来用

c. Redis的RedLock算法
使用了多个Redis实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。
尝试从N个互相独立Redis实例获取锁；
计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数(N / 2 + 1)实例上获取了锁，那么就认为锁获取成功了；如果锁获取失败，就到每个实例上释放锁。

4. Paxos

三类节点：
Proposer: 提议一个值；
Acceptor: 对每个提议进行投票；
Learner: 操作。

规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。

a. Prepare阶段
Proposer都会向Acceptor发送Prepare请求。
当Acceptor接收到一个Prepare请求，包含的提议为[n1, v1]，并且之前还未接收过Prepare请求，那么发送一个Prepare响应，设置当前接收到的提议为[n1, v1]，并且保证以后不会再接受序号小于n1的提议。
当Acceptor接收到一个Prepare请求，包含的提议为[n2, v2]，并且之前已经接收过提议[n1, v1]。如果n1 > n2，那么就丢弃该提议请求；否则，发送Prepare响应，该Prepare响应包含之前已经接收过的提议[n1, v1]，设置当前接收到的提议为[n2, v2]，并且保证以后不会再接受序号小于n2的提议。

b. Accept阶段
当一个Proposer接收到超过一半Acceptor的Prepare响应时，就可以发送Accept请求。

c. Learn阶段
Acceptor接收到Accept请求时，如果序号大于等于该Acceptor承诺的最小序号，那么就发送Learn提议给所有的Learner。当Learner发现有大多数的Acceptor接收了某个提议，那么该提议的提议值就被Paxos选择出来。


