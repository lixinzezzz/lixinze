1. 五层协议 / OSI七层协议

应用层: 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
表示层 (OSI): 数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
会话层 (OSI): 建立及管理会话。
传输层: 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议: TCP和UDP。
网络层: 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
数据链路层: 链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
物理层: 考虑的是怎样在传输媒体上传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

2. IP

会将数据报进行分片，分成多个IP数据报。每个数据报包含版本，首部长度，存活时间，检验和，标志，偏移，源地址，目的地址等信息。
ARP实现由IP地址得到MAC地址。

3. ICMP

ICMP是为了更有效地转发IP数据报和提高交付成功的机会。它封装在IP数据报中。ICMP报文分为差错报告报文和询问报文。
Ping和Traceroute是ICMP的两个重要应用。
Ping是通过向目的主机发送ICMP Echo请求报文，目的主机收到之后会发送Echo回答报文。Ping会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。
Traceroute发送的IP数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文，用来跟踪一个分组从源点到终点的路径。

4. TCP vs UDP

用户数据报协议UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。
UDP首部包括源端口，目的端口，长度，检验和等信息。

传输控制协议TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）。
TCP首部包括源端口，目的端口，序号，确认号，偏移，窗口等信息。

5. TCP三次握手

首先B处于监听状态，等待客户的连接请求。
A向B发送连接请求报文SYN，选择一个初始的序号x。
B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文SYN，ACK，确认号为 x+1，同时也选择一个初始的序号y。
A收到B的连接确认报文后，还要向B发出确认ACK，确认号为y+1，序号为x+1。
B收到A的确认后，连接建立。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。
客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

6. TCP四次挥手

A发送连接释放报文FIN。
B收到之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。
当B不再需要连接时，发送连接释放报文FIN。
A收到后发出确认，进入TIME-WAIT状态，等待2 MSL后释放连接。
B收到A的确认后释放连接。

7. Time Wait

客户端接收到服务器端的FIN报文后进入此状态，需要等待2 MSL。这么做有两个理由：
a. 确保最后一个确认报文能够到达。如果B没收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。
b. 让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

8. Close Wait

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

9. TCP可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

10. TCP滑动窗口, 流量控制

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。接收窗口只会对窗口内最后一个按序到达的字节进行确认。

流量控制是为了控制发送方发送速率，保证接收方来得及接收。
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

11. TCP拥塞控制

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。
a. 慢开始: 发送的最初执行慢开始，令cwnd = 1，发送方只能发送1个报文段；当收到确认后，将cwnd加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
b. 拥塞避免: 当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。
c. 快重传: 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。
d. 快恢复: 当只是丢失个别报文段，而不是网络拥塞时，执行快恢复，令ssthresh = cwnd / 2，cwnd = ssthresh，此时直接进入拥塞避免。
流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

12. TCP粘包

定义: TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包。
原因:
a. 发送方会收集多个小分组，在一个确认到来时一起发送
b. 接收方接收到数据包时，会将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。
解决:
靠应用层解决粘包问题。使用循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成。
格式化数据，使每条数据有固定的格式（开始符，结束符）；或附加长度，当发送每条数据时，将数据的长度一并发送，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。
UDP: UDP是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

13. Web页面请求过程 cyc P353

(DHCP配置IP地址)
DNS解析域名
HTTP请求页面 (三次握手, HTTP request (get) 请求页面, HTTP response 返回请求页面, 浏览器渲染页面)

14. HTTP报文

HTTP报文分为请求报文和响应报文。
请求报文包括：请求行、字段key-value pairs、一个空行和数据。
响应报文包括：状态行，字段key-value pairs，一个空行和数据。

15. HTTP方法

GET: 获取资源
POST: 传输实体主体
PUT: 上传文件
DELETE: 删除文件
PATCH: 对资源进行部分修改
OPTIONS: 查询支持的方法
HEAD: 获取报文首部
CONNECT: 要求在与代理服务器通信时建立隧道

16. HTTP状态码

1XX 信息
100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
2XX 成功
200 OK
204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
206 Partial Content ：表示客户端进行了范围请求，范围请求在传送大的媒体文件，或者与文件下载的断点续传功能搭配使用时非常有用。
3XX 重定向
301 Moved Permanently ：永久性重定向
302 Found ：临时性重定向
4XX 客户端错误
400 Bad Request ：请求报文中存在语法错误。
401 Unauthorized ：用户认证失败。
403 Forbidden ：请求被拒绝。
404 Not Found
5XX 服务器错误
500 Internal Server Error ：服务器正在执行请求时发生错误。
503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

17. HTTP 1.0 / 1.1 / 2.0 cyc P374

HTTP 2.0:
    二进制分帧层: 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的
    服务端推送: 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了
    首部压缩: 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输; 也对首部字段进行了压缩
    多路复用: 基于二进制数据帧的传输，所以可以做到乱序的传输，不会存在阻塞
HTTP 1.1: 
    默认长连接: 建立一次 TCP 连接就能进行多次 HTTP 通信
    流水线: 在同一条长连接上连续发出请求，而不用等待响应返回，但服务器需要按照顺序一个一个响应；可能有阻塞的问题，若上一响应迟迟不回，后面的响应都会被阻塞到

18. HTTPS握手 cyc P372

客户端发送建立连接请求
服务端发送自己公钥证书
客户端验证服务端身份，生成session key并用服务端公钥加密并传送
服务端用私钥解密获得session key
两方随后用session key加密通信
