1. 事务ACID

a. 原子性: 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
b. 一致性: 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
c. 隔离性: 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
d. 持久性: 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

2. 并发一致问题

修改丢失，脏读，不可重复读，幻影读

3. 锁类型

排它锁，简写为 X 锁，又称写锁。
共享锁，简写为 S 锁，又称读锁。

4. 乐观锁悲观锁

悲观锁: 在数据库操作上加锁
乐观锁: 在表中维护一个版本号，在更新操作时，检查版本号是否对齐，失败就循环继续

5. 三级封锁协议

一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题。
二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题。
三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题。

6. 两段锁协议

每个对象加锁和解锁分为两个阶段进行。保证可串行化。

7. MySQL隔离级别

未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。会产生脏读，不可重复读，幻影读的问题。
提交读：一个事务只能读取已经提交的事务所做的修改。会产生不可重复读，幻影读的问题。
可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。会产生幻影读的问题。
可串行化：强制事务串行执行。需要加锁实现。

8. MVCC cyc P12


9. Next-key Lock

在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。

10. redo vs undo

redo log: 物理日志; 保证持久性
undo log: 逻辑日志, 也用于MVCC中; 保证原子性

11. Force & Steal 

steal/no-steal: 是否允许一个uncommitted的事务将修改更新到磁盘; steal可能需要undo.
force/no-force: 是否必须在committed后立刻持久化到磁盘; no-force可能需要redo.

12. WAL

在持久化表之前先持久化日志

13. 恢复和checkpoint

读取double write 文件，恢复磁盘文件（数据页和undo页）到初始状态。
读取redo log 日志文件，获取最后一次的checkPoint 的 LSN
重做 check point 开始到结尾的redo log
根据BinaryLog（判断事务是否完成）与undoLog 回滚尚未完成的事务

14. redolog vs binlog

a. 这两者使用方式不一样：binlog 是用作人工恢复数据，redo log 是 MySQL 自己使用，用于保证在数据库崩溃时的事务持久性。
b. redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的,所有引擎都可以使用。
c. redo log 文件是固定大小的，是循环写的，写满了会从头继续写，而 binlog 是追加写的，写满了再新建文件接着写。
d. redo log物理日志，binlog逻辑日志。

15. mysql 2PC (redolog & binlog)

在最后提交事务的时候，需要有3个步骤：
a. 写入redo log，处于prepare状态
b. 写binlog
c. 修改redo log状态为commit
为了是redo log binlog相匹配

16. 分布式数据库 2PC

第一步coordinator向每个server询问能不能commit
第二步coordinator发出commit / abort指令

17. 范式与反范式

第一范式 (1NF): 属性不可分。
第二范式 (2NF): 每个非主属性完全函数依赖于键码。
第三范式 (3NF): 非主属性不传递函数依赖于键码。

范式好处: 减少冗余数据, 使得修改更简单, 表也更小
范式坏处: 查询时经常用到连接, 影响效率

18. 索引: B+树 vs 红黑树 vs B树 cyc P52

19. MySQL索引

B+树索引, 哈希索引, 空间数据索引, 全文索引 (使用倒排索引实现)
自适应哈希索引

20. 索引优化

1. 独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
2. 多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。
3. 索引列的顺序：让选择性最强的索引列放在前面。
4. 覆盖索引：索引包含所有需要查询的字段的值。
5. 索引条件下推：如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。
6. 前缀索引：表中增加一列保存字符串的前缀，并增加在索引里，把前缀放在完整字符串前面加快查询 select * from table where prefix = 'a' and name = 'ab';
7. 重复索引和冗余索引
8. 减少索引和数据碎片：比如InnoDB删除数据时，这一段空间就会被留空，如果一段时间内大量删除数据，就会导致留空的空间比实际的存储空间还要大，这时候如果进行新的插入操作时，MySQL会尝试重新使用这部分空间，但是依然无法彻底占用，这样就会产生碎片；可以通过 OPTIMIZE TABLE 

21. 查询优化

1. 使用 Explain 和慢查询日志 进行分析
2. 减少请求的数据量: 通过select 和 limit
3. 减少服务器端扫描的行数: 走索引，尤其聚簇索引和覆盖索引
4. 切分大查询: 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
5. 分解大连接查询: 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联

22. 唯一索引

通过unique关键字修饰的字段; 主键是唯一的, 唯一的不一定是主键; MySQL给唯一的字段自动创建索引来实现唯一性

23. InnoDB vs MyISAM

innodb支持表级锁行级锁，myisam支持表级锁
innodb支持事务
innodb支持外键
myisam支持表压缩和空间数据索引
innodb聚簇索引

24. 主从复制

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。
binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

25. 聚簇索引
Innodb: 数据只存在聚簇索引叶子结点上；非聚簇索引叶子结点存储的是主键值。
Myisam: 数据顺序存在磁盘里；聚簇索引和非聚簇索引没有区别，叶子结点存储的是行数。
