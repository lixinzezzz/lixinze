1. 运行时数据区域

包括程序计数器，Java虚拟机栈，本地方法栈，堆，方法区等

2. 判断垃圾

引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

3. GC Root

GC Roots 一般包含：虚拟机栈中局部变量表中引用的对象，本地方法栈中 JNI 中引用的对象，方法区中类静态属性和常量引用的对象

4. 引用类型

强引用：被强引用关联的对象不会被回收。
软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。
弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
虚引用：一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

5. 垃圾收集算法

标记 - 清除：
在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记；在清除阶段，会进行对象回收并取消标志位
缺点：标记和清除过程效率都不高，且会产生大量不连续的内存碎片，导致无法给大对象分配内存。

标记 - 整理：
先程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记；再让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
优点: 不会产生内存碎片
不足: 需要移动大量对象，处理效率比较低。

复制：
将新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。
HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

分代收集：
一般将堆分为新生代和老年代。新生代使用：复制算法；老年代使用：标记 - 清除 或者 标记 - 整理 算法

6. CMS

CMS是使用标记 - 清除算法的能并发运行的垃圾收集器。
分为四个流程：初始标记，并发标记，重新标记，并发清除。其中初始标记和重新标记需要停顿。
缺点有:
a. 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。
b. 标记 - 清除算法导致的空间碎片。

7. G1

G1 可以直接对新生代和老年代一起回收。G1 把堆划分成多个大小相等的Region，新生代和老年代不再物理隔离，且使得每个Region可以单独进行垃圾回收。
G1 能分析记录每个 Region 垃圾回收时间以及回收所获得的空间，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
大小超过Region size一半的大对象存在连续的Humongous区中。
整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的。
分为四个流程：初始标记，并发标记，最终标记，筛选回收。其中初始标记，最终标记和筛选回收需要停顿。
优点有：
a. 不会产生内存空间碎片.
b. 可预测的停顿.

8. Minor GC vs Full GC

Minor GC: 当 Eden 空间满时，就将触发一次 Minor GC。
Full GC: 全量收集的 GC，对整个堆进行回收
a. 调用 System.gc()
b. 老年代空间不足
c. 空间分配担保失败
d. Concurrent Mode Failure

9. 内存分配策略

a. 对象优先在 Eden 分配
b. 大对象直接进入老年代
c. 长期存活的对象进入老年代
d. 动态对象年龄判定: 如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到要求的年龄。
e. 空间分配担保: Minor GC 前会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若失败则可能进行Full GC。

10. Concurrent Mode Failure

浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

11. Promotion Failure:

老年代没有足够的空间分配给新生代晋升的对象

12. 类加载过程 cyc P178

加载: 通过类的完全限定名称获取定义该类的二进制字节流; 转换为方法区的运行时存储结构; 生成一个代表该类的 Class 对象;
验证: 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全;
准备: 准备阶段为类变量分配内存并设置初始值;
解析: 将常量池的符号引用替换为直接引用;
初始化: 执行类中定义的 Java 程序代码完成初始化

13. 符号引用 vs 直接引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。
直接引用可以是直接指向目标的指针。

14. 类加载器分类

启动类加载器
扩展类加载器
应用程序类加载器：它负责加载用户类路径上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
用户自定义类加载器

15. 双亲委派模型

工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。
好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

16. 自定义类加载器
需要继承自 java.lang.ClassLoader。其中loadClass()实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它；findClass()用于加载文件系统上的类，需要重写。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。